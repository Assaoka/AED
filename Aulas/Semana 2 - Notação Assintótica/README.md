<h1 align="center"> Semana 2 - Nota√ß√£o Assint√≥tica </h1>

Em Breve...


<details><summary><h3> Problema 1 - Contagem de Letras em Strings </h3></summary>

&emsp;&emsp;A contagem de letras consiste em saber quantas vezes determinadas letras s√£o encontradas na string. Deve-se escrever um programa que aborde essa caracter√≠stica, ou seja, escreva um programa que recebe uma string de comprimento N da entrada padr√£o e contabiliza a quantidade de cada letra do alfabeto presente de forma case insensitive (desconsiderando mai√∫sculas e min√∫sculas).

<b>Entrada:</b> Uma string de N caracteres (supondo tamanho m√°ximo 256 caracteres).

<br><b>Sa√≠da:</b> Exibir uma lista de caracteres presentes em ordem lexicogr√°fica crescente e suas respectivas frequ√™ncias.

<br><b>Dicas:</b>
<br>‚öô Lembrar que toda string em C ou C++ contem o caractere especial ‚Äò\0‚Äô para demarcar o t√©rmino do string. Deve-se levar este fato em considera√ß√£o na aloca√ß√£o do vetor de caracteres, e nas manipula√ß√µes para determina√ß√£o de tamanhos e c√≥pias.
<br>‚öô O programa deve estar preparado para leituras de texto contendo espa√ßos em branco, n√∫meros e caracteres especiais, por√©m, somente as letras ser√£o contabilizadas.

| Exemplo de Entrada | Exemplo de Sa√≠da |
|--|--|
| Hello world! | D 1<br> E 1<br> H 1<br> L 3<br> O 2<br> R 1<br> W 1 |

<br>üîπ Voc√™ pode encontrar a Minha Resolu√ß√£o em C neste<a href="https://github.com/Assaoka/UNIFESP--Algoritmos_e_Estruturas_de_Dados/blob/main/Aulas/Semana%202%20-%20Nota%C3%A7%C3%A3o%20Assint%C3%B3tica/JoaoAssaoka_rn168863-AP1.c"> link</a>.


</details>





<details><summary><h3> Buscar o Maior e o Menor Valor de Forma Eficiente </h3></summary>
&emsp;&emsp;Este algoritmo em C resolve o problema de encontrar o maior e o menor elemento em um vetor de inteiros de uma maneira mais inteligente e eficiente.

&emsp;&emsp;O algoritmo come√ßa verificando o tamanho do vetor `Tam`. Se o tamanho for √≠mpar, utilizamos o primeiro elemento `V[0]` para inicializar tanto o `Maior` quanto o `Menor`. Se o tamanho for par, os dois primeiros elementos s√£o comparados, e o maior √© atribu√≠do a `Maior`, e o menor √© atribu√≠do a `Menor`.

&emsp;&emsp;Em seguida, o algoritmo entra em um loop que percorre o vetor a partir do terceiro elemento. Para cada par de elementos (`V[i]` e `V[i + 1]`), ele realiza as seguintes compara√ß√µes:
- Se `V[i]` for maior que `V[i + 1]`, ele compara `V[i]` com o valor atual de `Maior` e `V[i + 1]` com o valor atual de `Menor`.
- Se `V[i]` n√£o for maior que `V[i + 1]`, ele compara `V[i + 1]` com o valor atual de `Maior` e `V[i]` com o valor atual de `Menor`.

Dessa forma, `Maior` e `Menor` s√£o atualizados conforme o algoritmo encontra valores maiores ou menores no vetor.

Este algoritmo √© eficiente, pois reduz o n√∫mero de compara√ß√µes necess√°rias, mesmo para vetores de tamanho grande. Al√©m disso, ele lida adequadamente com vetores de tamanho √≠mpar, garantindo que o primeiro elemento seja tanto o maior quanto o menor, quando necess√°rio.

üîπ Voc√™ pode encontrar o c√≥digo em C neste [link](https://github.com/Assaoka/UNIFESP--Algoritmos_e_Estruturas_de_Dados/blob/main/Aulas/Semana%202%20-%20Nota%C3%A7%C3%A3o%20Assint%C3%B3tica/MaiorMenor_Eficiente.c). Espero que esta explica√ß√£o ajude a compreender como o algoritmo funciona.
</details>
